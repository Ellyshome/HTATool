
function colLetterToIndex(letter) {  //å°† Excel åˆ—å­—æ¯è½¬æ¢ä¸º 0 åŸºç¡€ç´¢å¼•ã€‚
    // A -> 1, B -> 2 ... Z -> 26, AA -> 27 ...
    let col = 0;
    for (let i = 0; i < letter.length; i++) {
        col = col * 26 + (letter.charCodeAt(i) - 64);
    }
    return col - 1; // return 0-based
}

function indexToColLetter(index) {  //å°† 0 åŸºç¡€ç´¢å¼•è½¬æ¢ä¸º Excel åˆ—å­—æ¯ã€‚
    // 0 -> A
    let n = index + 1;
    let s = '';
    while (n > 0) {
        let m = (n - 1) % 26;
        s = String.fromCharCode(65 + m) + s;
        n = Math.floor((n - 1) / 26);
    }
    return s;
}

function isCellMasterInRange(r, c, rangeStr) {   //æ£€æŸ¥å•å…ƒæ ¼æ˜¯å¦æ˜¯æŒ‡å®šèŒƒå›´çš„ä¸»å•å…ƒæ ¼ã€‚
    const range = decodeRange(rangeStr);
    return (r === range.s.r && c === range.s.c);
}

function getMR(ws) {//è·å–sheetçš„åˆå¹¶èŒƒå›´ã€‚
    // è·å–å·¥ä½œè¡¨ä¸­çš„æ‰€æœ‰åˆå¹¶èŒƒå›´ï¼Œè¿”å›æ•°ç»„ï¼šrangeStrï¼Œå¦‚ ["A1:C1", "E2:E3", ...]
    if (!ws) {
        console.warn('getMRï¼šå·¥ä½œè¡¨ ws ä¸å­˜åœ¨');
        return [];
    }
    try {
        const mergedRanges = ws.model.merges;
        // å°† MergeRange å¯¹è±¡è½¬ä¸ºèŒƒå›´å­—ç¬¦ä¸²ï¼ˆå¦‚ MergeRange â†’ "A1:C1"ï¼‰
        return mergedRanges;
        //return mergedRanges.map(range => range.address);
    } catch (e) {
        // ğŸŒŸ ä¿®æ­£ï¼šè¾“å‡ºå…·ä½“é”™è¯¯æ—¥å¿—ï¼Œæ–¹ä¾¿æ’æŸ¥
        console.error('getMRï¼šè·å–åˆå¹¶èŒƒå›´å¤±è´¥', e.message);
        return [];
    }
}

function isCellInRange(cell, rangeS) {   //æ£€æŸ¥å•å…ƒæ ¼æ˜¯å¦åœ¨æŒ‡å®šèŒƒå›´å†…ã€‚
    const range = decodeRange(rangeS);
    r = decodeRange(cell.address).s.r;
    c = decodeRange(cell.address).s.c;
    return (r >= range.s.r && r <= range.e.r && c >= range.s.c && c <= range.e.c);
}

function getMergeState(cell) {   //è·å–å•å…ƒæ ¼çš„åˆå¹¶çŠ¶æ€ã€‚
    const ranges = getMR(cell.worksheet);
    r = decodeRange(cell.address).s.r;
    c = decodeRange(cell.address).s.c;
    for (const range of ranges) {
        if (isCellInRange(cell, range)) {
            //0:éåˆå¹¶å•å…ƒæ ¼ 1: ä¸»å•å…ƒæ ¼ï¼Œ2ï¼šéä¸»å•å…ƒæ ¼
            const ran = decodeRange(range);
            if (r === ran.s.r && c === ran.s.c) return 1;
            return 2;
        }
    }
    return 0;
}

function deepClone(obj) {// é€šç”¨æ·±åº¦å…‹éš†å‡½æ•°ï¼ˆå¿…é¡»ä¿ç•™ï¼Œå¦åˆ™æ ·å¼åµŒå¥—å¯¹è±¡ä¼šæµ…å¤åˆ¶ï¼‰
    if (obj === null || typeof obj !== "object") return obj;
    if (obj instanceof Date) return new Date(obj.getTime());
    if (obj instanceof Array) return obj.map(item => deepClone(item));
    const cloneObj = {};
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            cloneObj[key] = deepClone(obj[key]);
        }
    }
    return cloneObj;
}

function copyCellValueAndStyleExcelJS(targetCell, sourceCell) {//å•å…ƒæ ¼å¤åˆ¶ï¼Œæ ¸å¿ƒå‡½æ•°ã€‚
    // è¾¹ç•Œæ ¡éªŒï¼šç›®æ ‡å•å…ƒæ ¼ä¸å­˜åœ¨ç›´æ¥è¿”å›
    if (!targetCell) return;

    // ğŸŒŸ ç¬¬ä¸€æ­¥ï¼šæ·±åº¦å¤åˆ¶ã€Œå€¼ã€ï¼ˆæŒ‰ç±»å‹å¤„ç†ï¼Œé‡ç‚¹æ”¯æŒå¯Œæ–‡æœ¬ï¼‰
    if (!sourceCell) {
        // æºå•å…ƒæ ¼ä¸å­˜åœ¨ï¼šæ¸…ç©ºç›®æ ‡å•å…ƒæ ¼çš„å€¼å’Œæ‰€æœ‰æ ·å¼
        targetCell.value = null;
        ['font', 'fill', 'border', 'alignment', 'numFmt'].forEach(key => delete targetCell[key]);
        return;
    }

    const sourceVal = sourceCell.value;
    if (sourceVal === undefined || sourceVal === null) {
        targetCell.value = null;
    } else {
        // æŒ‰å€¼ç±»å‹é’ˆå¯¹æ€§å¤åˆ¶ï¼Œä¿ç•™åŸæ•°æ®ç»“æ„
        if (sourceVal.richText && Array.isArray(sourceVal.richText)) {
            // 1. å¯Œæ–‡æœ¬ï¼šæ·±åº¦å…‹éš† richText æ•°ç»„åŠå†…éƒ¨ font æ ·å¼ï¼ˆä¿ç•™åŸæœ‰æ­£ç¡®é€»è¾‘ï¼‰
            targetCell.value = {
                richText: sourceVal.richText.map(segment => ({
                    ...segment, // å…‹éš†æ–‡æœ¬åŠå…¶ä»–æ®µè½å±æ€§
                    font: segment.font ? deepClone(segment.font) : undefined // æ®µè½çº§å­—ä½“æ ·å¼
                }))
            };
        } else if (sourceVal.formula) {
            // 2. å…¬å¼ï¼šå…‹éš† formula å’Œ resultï¼ˆä¿ç•™å¯è®¡ç®—æ€§ï¼‰
            targetCell.value = deepClone(sourceVal);
        } else if (sourceVal instanceof Date) {
            // 3. æ—¥æœŸï¼šå…‹éš†æ—¶é—´æˆ³ï¼ˆé¿å…å¼•ç”¨å†²çªï¼‰
            targetCell.value = new Date(sourceVal.getTime());
        } else if (typeof sourceVal === 'object') {
            // 4. å…¶ä»–å¯¹è±¡/æ•°ç»„ï¼šæ·±åº¦å…‹éš†
            targetCell.value = deepClone(sourceVal);
        } else {
            // 5. åŸºç¡€ç±»å‹ï¼šç›´æ¥èµ‹å€¼
            targetCell.value = sourceVal;
        }
    }

    // ğŸŒŸ ç¬¬äºŒæ­¥ï¼šè¡¥å……ã€Œå•å…ƒæ ¼å…¨å±€æ ·å¼ã€æ·±åº¦å¤åˆ¶ï¼ˆæ ¸å¿ƒä¿®æ­£ï¼šæ–°å¢è¿™éƒ¨åˆ†ï¼‰
    const globalStyles = ['fill', 'border', 'alignment', 'numFmt', 'font'];
    globalStyles.forEach(styleKey => {
        const sourceStyle = sourceCell[styleKey];
        if (sourceStyle) {
            // æ·±åº¦å…‹éš†æ ·å¼ï¼ˆé¿å…å¼•ç”¨å†²çªï¼ŒnumFmtæ˜¯å­—ç¬¦ä¸²/æ•°å­—ï¼Œç›´æ¥èµ‹å€¼å³å¯ï¼‰
            targetCell[styleKey] = styleKey === 'numFmt' 
                ? sourceStyle 
                : deepClone(sourceStyle);
        } else {
            // æºå•å…ƒæ ¼æ— è¯¥æ ·å¼ï¼šåˆ é™¤ç›®æ ‡å•å…ƒæ ¼çš„æ—§æ ·å¼ï¼ˆé¿å…æ®‹ç•™ï¼‰
            delete targetCell[styleKey];
        }
    });
}

/**
 * å°†æºå·¥ä½œè¡¨ä¸­çš„æºè¡Œçš„æ¨ªå‘åˆå¹¶å¤åˆ¶åˆ°ç›®æ ‡å·¥ä½œè¡¨çš„ç›®æ ‡è¡Œã€‚
 * @param {object} sourceSheet - æºå·¥ä½œè¡¨å¯¹è±¡ã€‚
 * @param {object} targetSheet - ç›®æ ‡å·¥ä½œè¡¨å¯¹è±¡ã€‚
 * @param {number} sourceRow - 0 åŸºç¡€æºè¡Œç´¢å¼•ã€‚
 * @param {number} targetRow - 0 åŸºç¡€ç›®æ ‡è¡Œç´¢å¼•ã€‚
 * @param {number} sourceNameCol - æºå·¥ä½œè¡¨ä¸­å§“ååˆ—çš„ 0 åŸºç¡€åˆ—ç´¢å¼•ã€‚
 * @param {number} targetNameCol - ç›®æ ‡å·¥ä½œè¡¨ä¸­å§“ååˆ—çš„ 0 åŸºç¡€åˆ—ç´¢å¼•ã€‚
 */
function syncMergesExcelJS(sourceSheet, targetSheet, sourceRow, targetRow, sourceNameCol, targetNameCol) {//åŒæ­¥ åˆå¹¶ã€‚
    if (!sourceSheet || !sourceSheet._merges) return;
    // æ¸…ç†ç›®æ ‡è¡Œä¸Šçš„åˆå¹¶
    unmergeRowExcelJS(targetSheet, targetRow);

    const ranges = getMR(sourceSheet);//è·å–å·¥ä½œè¡¨ åˆå¹¶èŒƒå›´
    for (const rangeStr of ranges) {
        const dec = decodeRange(rangeStr);
        // æ£€æŸ¥ sourceRow æ˜¯å¦å¤„äºè¯¥åˆå¹¶åŒºé—´çš„è¡ŒèŒƒå›´
        if (sourceRow >= dec.s.r && sourceRow <= dec.e.r) {
            // è®¡ç®—ç›¸å¯¹äºå§“ååˆ—çš„åç§»
            const startRel = dec.s.c - sourceNameCol;
            const endRel = dec.e.c - sourceNameCol;
            const newStartCol = targetNameCol + startRel;
            const newEndCol = targetNameCol + endRel;
            // ExcelJS mergeCells å‚æ•°æ˜¯ (top,left,bottom,right) with 1-based indexes
            try {
                targetSheet.mergeCells(targetRow + 1, newStartCol + 1, targetRow + 1, newEndCol + 1);
            } catch (e) {
                console.warn('mergeCells failed', e, rangeStr);
            }
        }
    }
}



function decodeRange(rangeStr) {  //è§£ç  Excel èŒƒå›´å­—ç¬¦ä¸²ã€‚
    // "A1:C3" -> {s:{r,c}, e:{r,c}}

    if (!rangeStr.includes(':')) {
        const a = a1ToRC(rangeStr);
        return { s: a, e: a };
    }
    const parts = rangeStr.split(':');
    const s = a1ToRC(parts[0]);
    const e = a1ToRC(parts[1]);
    
    return { s, e };
}



function unmergeRowExcelJS(ws, targetRow) {// åœ¨ç›®æ ‡å·¥ä½œè¡¨ä¸Šåˆ é™¤åŒ…å«ç›®æ ‡è¡Œçš„æ‰€æœ‰åˆå¹¶ã€‚
    if (!ws) return;
    const rowNumber = targetRow + 1;
    const ranges = getMR(ws);
    for (const range of ranges) {
        const dec = decodeRange(range);
        if (rowNumber >= dec.s.r + 1 && rowNumber <= dec.e.r + 1) {
            try {
                ws.unMergeCells(range);
            } catch (e) {
                // ignore
            }
        }
    }
}

function changeSheetS_ExcelJS(flag) {//æ ¸å¿ƒå‡½æ•°ï¼Œå¯¹æ¯”ä¸ä¿®æ”¹sheetã€‚
    masterSheet=workbook.worksheets[0];
    const diffs = [];
    let modifiedCount = 0;  //ä¿®æ”¹è®¡æ•°
    diffs.forEach(doc => {//å¯¹æ¯ä¸ªåŒ¹é…æˆåŠŸçš„åŒ»ç”Ÿè¿›è¡Œå¤„ç†ã€‚
        subSheet=doc.cell_s.worksheet;
        const masterInfo = doc.cell_m;
        const subNameCol = doc.cell_s.col; // 0-based
        const masterNameCol = masterInfo.col;
        
        // å¤„ç†åˆå¹¶å•å…ƒæ ¼åŒæ­¥
        if (flag === 1) {// sub -> master åˆå¹¶å¤åˆ¶ã€‚
            syncMergesExcelJS(subSheet, masterSheet, doc.row, masterInfo.row, subNameCol, masterNameCol);
        } else if (flag === 2) {// master -> subåˆå¹¶å¤åˆ¶ã€‚
            syncMergesExcelJS(masterSheet, subSheet, masterInfo.row, doc.row, masterNameCol, subNameCol);
        }

        for (let day = 1; day <= 14; day++) {//åˆå¹¶å¤åˆ¶
            const subC = subNameCol + day;
            const masterC = masterNameCol + day;

            //è·å–ä¸»ã€åˆ†è¡¨ç­æ¬¡å•å…ƒæ ¼å¯¹è±¡
            
            const subCellObj = subSheet.getRow(doc.cell_s.row).getCell(subC);
            const masterCellObj = masterSheet.getRow(doc.cell_m.row).getCell(masterC);
            
            // è°ƒç”¨å‡½æ•°è·å–cellçš„å€¼ï¼ˆå®‰å…¨çš„è·å–ï¼‰
            
            const subVal = getCellSafeValue(subCellObj);
            const masterVal = getCellSafeValue(masterCellObj);
            //const subVal = subCellObj.value
            //const masterVal = masterCellObj.value
            
                // ä¿®æ”¹
                let srcCell = (flag === 1) ? subCellObj : masterCellObj;
                let tgtCell = (flag === 1) ? masterCellObj : subCellObj;

                // å¦‚æœæºä¸ºåˆå¹¶åŒºåŸŸçš„éä¸»å•å…ƒæ ¼ï¼Œå¯»æ‰¾ä¸»å•å…ƒæ ¼
                const srcSheet = (flag === 1) ? subSheet : masterSheet;
                const rIndex = (flag === 1) ? doc.row : masterInfo.r;
                const cIndex = (flag === 1) ? subC : masterC;
                const srcMergeState = getMergeState(srcSheet, rIndex, cIndex);
                if (srcMergeState === 2) {
                    // æ‰¾åˆ°åˆå¹¶åŒºé—´å¹¶ä½¿ç”¨ä¸»å•å…ƒæ ¼
                    const ranges = getMR(srcSheet);
                    for (const range of ranges) {
                        if (isCellInRange(rIndex, cIndex, range)) {
                            const mainRC = decodeRange(range).s; // ä¸»å•å…ƒæ ¼åæ ‡
                            srcCell = srcSheet.getRow(mainRC.r + 1).getCell(mainRC.c + 1);
                            break;
                        }
                    }
                }

                // æ‰§è¡Œå¤åˆ¶ï¼ˆå€¼ + æ ·å¼ï¼‰
                copyCellValueAndStyleExcelJS(tgtCell, srcCell);

                modifiedCount++;
            }
        }
    );
    return { diffs, modifiedCount, matchedCount: matched.length };//diffs:å·®å¼‚åˆ—è¡¨ï¼ŒmodifiedCount:ä¿®æ”¹è®¡æ•°ï¼ŒmatchedCount:åŒ¹é…åŒ»ç”Ÿè®¡æ•°ã€‚
}

/**
 * åœ¨ ExcelJSï¼ˆæµè§ˆå™¨ç‰ˆï¼‰ä¸­å¤åˆ¶ä¸€ä¸ªçŸ©å½¢èŒƒå›´åˆ°æŒ‡å®šå·¦ä¸Šè§’å•å…ƒæ ¼ã€‚
 *
 * @param {Worksheet} ws        - å·¥ä½œè¡¨å¯¹è±¡
 * @param {string} srcRange     - æºèŒƒå›´ï¼Œå¦‚ "B2:D6"
 * @param {string} dstStart     - ç›®æ ‡å·¦ä¸Šè§’ï¼Œå¦‚ "F10"
 */
function copyRange() {
    const ExcelJS = window.ExcelJS;
    ws = workbook.worksheets[0]
    //const src = ExcelJS.Workbook.xlsx.decodeRange(srcRange); // {top, left, bottom, right}
    //const dst = ExcelJS.Workbook.xlsx.decodeAddress(dstStart); // {row, col}
    const src = {top:2,left:'B',bottom:8,right:'P'}
    const dst = {row:2, col:'T'}
    
    const rowOffset = dst.row - src.top;
    const colOffset = dst.col - src.left;

    /* 1. å¤åˆ¶å•å…ƒæ ¼å†…å®¹ä¸æ ·å¼
    for (let r = src.top; r <= src.bottom; r++) {
        for (let c = src.left; c <= src.right; c++) {

            const srcCell = ws.getCell(r, c);
            const dstCell = ws.getCell(r + rowOffset, c + colOffset);

            // æ‹·è´å€¼ï¼ˆæ”¯æŒå…¬å¼ï¼‰
            dstCell.value = srcCell.value;

            // æ‹·è´æ‰€æœ‰æ ·å¼
            dstCell.style = JSON.parse(JSON.stringify(srcCell.style));
        }
    }*/

    // 2. å¤åˆ¶åˆå¹¶å•å…ƒæ ¼
    ws.model.merges.forEach(m => {
        console.log('1111')
        if (
            m.top    >= src.top    && m.bottom <= src.bottom &&
            m.left   >= src.left   && m.right  <= src.right
        ) {
            const newMerge = {
                top:    m.top    + rowOffset,
                bottom: m.bottom + rowOffset,
                left:   m.left   + colOffset,
                right:  m.right  + colOffset
            };
            ws.mergeCells(
                newMerge.top, newMerge.left,
                newMerge.bottom, newMerge.right
            );
        }
    });
}